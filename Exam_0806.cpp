
#if 0
/*
一块花布条，里面有些图案，另有一块直接可用的小饰条，里面也有一些图案。
对于给定的花布条和小饰条，计算一下能从花布条中尽可能剪出几块小饰条来呢？


Input
输入中含有一些数据，分别是成对出现的花布条和小饰条，其布条都是用可见ASCII字符表示的，
可见的ASCII字符有多少个，布条的花纹也有多少种花样。花纹条和小饰条不会超过1000个字符长。
如果遇见#字符，则不再进行工作。         
Output
输出能从花纹布中剪出的最多小饰条个数，如果一块都没有，那就老老实实输出0，每个结果之间应换行。       


abcde a3
aaaaaa  aa
#
Sample Output
0
3     

  思路：  将布条看作a[]字符串，将饰条看作b[]字符串，判断a[]是否为#字符后，将b[]中字符与a[]对照，发现b[]第一个字符有相同，用一个数记录a[],b[]相同字符个数，用一个循环来判断这个数是否与b[]长度相同，相同就说明可以剪下来一个，然后使a[]字符串从剪下来的部分后面再接着重复上面过程，看最终能剪下来多少个b[]字符串。

我自己刚开始的出错：1.开始我用gets()去输入a[]，b[]，就与题目不符合了，题目要输入再一行.
 2.要是a[]输入#后，是不用输入不b[]就结束了，我想着在scanf中直接把a[],b[]输入，就错了，而且还不                                          能 一直循环.

*/
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h> 
#include<string.h>
int main()
{
	char a[1000], b[1000];
	int i, j, stra, strb, k, p, l;          //i，j循环，stra，strb代表长度，k记录i的位置，p记录a[]，b[]是否全部,l代表多少个 
	while (scanf("%s", a) != EOF)           //当a有输入时 
	{
		l = 0;
		if (a[0] == '#')
			return 0;
		else scanf("%s", b);
		stra = strlen(a);
		strb = strlen(b);
		for (i = 0; i < stra; i++)                 //寻找从某个字符开始相同 
		{
			if (a[i] == b[0])
			{
				k = i;
				for (j = 0, p = 0; j < strb; j++, k++)
				{
					if (a[k] == b[j])
						p++;                      //记录相同字符个数 
				}
				if (p == strb)                   //看是否全部相同 
				{
					l++;
					i = i - 1 + strb;               //将i的位置调到下此开始的前面一个字符位置，因为有i++ 
				}
			}
		}
		printf("%d\n", l);
	}
}


#endif 

